# Reglas de Estructura del Proyecto

## Organización de Paquetes

### Core (`packages/core/`)
Paquetes fundamentales que no dependen de otros paquetes internos:
- `contracts/` - Contratos de eventos y tipos compartidos
- `types/` - Tipos TypeScript base (si se crea)
- `utils/` - Utilidades generales (si se crea)

### Security (`packages/security/`)
Todo lo relacionado con seguridad y autenticación:
- `security/` - Risk scoring, fraud detection, behavioral analytics
- `zero-trust/` - Zero-trust architecture
- `threat-intelligence/` - Threat intelligence engine
- `encryption/` - Encryption y key management
- `quantum-resistant/` - Quantum-resistant cryptography
- `behavioral-biometrics/` - Behavioral biometrics
- `continuous-auth/` - Continuous authentication
- `ml-auth/` - ML-based authentication

### Identity (`packages/identity/`)
Gestión de identidad y autenticación:
- `decentralized-identity/` - DID/Verifiable Credentials
- `zero-knowledge/` - Zero-knowledge proofs
- `session-management/` - Session management
- `rbac-advanced/` - RBAC/ABAC avanzado

### Infrastructure (`packages/infrastructure/`)
Comunicación y servicios base:
- `event-bus/` - Event bus (NATS)
- `service-client/` - HTTP client con resilience
- `cache/` - Distributed caching
- `rate-limiting/` - Rate limiting básico
- `ml-rate-limiting/` - ML-based rate limiting
- `ddos-protection/` - DDoS protection

### Observability (`packages/observability/`)
Monitoreo y análisis:
- `observability/` - OpenTelemetry, logging, metrics
- `analytics/` - Analytics y reporting
- `anomaly-detection/` - Anomaly detection

### Compliance (`packages/compliance/`)
Cumplimiento normativo:
- `compliance/` - GDPR, SOC2 automation
- `blockchain-audit/` - Blockchain audit trail
- `webhooks/` - Webhook system

### Advanced (`packages/advanced/`)
Características innovadoras:
- `homomorphic-encryption/` - Homomorphic encryption
- `federated-learning/` - Federated learning
- `graphql-api/` - GraphQL API layer

### Performance (`packages/performance/`)
Optimización y escalabilidad:
- `performance/` - Query optimization, batching
- `multi-region/` - Multi-region support
- `self-healing/` - Self-healing system

## Reglas de Dependencias

1. **Core** → No depende de otros paquetes internos
2. **Security** → Puede depender de Core
3. **Identity** → Puede depender de Core y Security
4. **Infrastructure** → Puede depender de Core
5. **Observability** → Puede depender de Core
6. **Compliance** → Puede depender de Core, Security, Identity
7. **Advanced** → Puede depender de cualquier paquete base
8. **Performance** → Puede depender de Core e Infrastructure
9. **Apps** → Pueden depender de cualquier paquete

## Convenciones de Nomenclatura

- **Carpetas**: kebab-case (`zero-knowledge`, `event-bus`)
- **Archivos TypeScript**: kebab-case (`risk-scoring.ts`, `event-bus.ts`)
- **Clases**: PascalCase (`RiskScoringEngine`, `EventBus`)
- **Funciones/Variables**: camelCase (`calculateRisk`, `eventBus`)
- **Constantes**: UPPER_SNAKE_CASE (`MAX_RETRIES`, `DEFAULT_TIMEOUT`)

## Estructura de Paquetes

Cada paquete debe seguir esta estructura:

```
package-name/
├── src/
│   ├── index.ts              # Public API (barrel export)
│   ├── types.ts              # TypeScript types/interfaces
│   ├── [feature].ts         # Implementaciones principales
│   └── __tests__/           # Tests unitarios
│       └── [feature].test.ts
├── package.json
├── tsconfig.json
└── tsup.config.ts
```

## Estructura de Servicios

Cada servicio (app) debe seguir esta estructura:

```
service-name/
├── src/
│   ├── main.ts              # Entry point
│   ├── modules/             # Módulos NestJS
│   │   ├── [domain]/
│   │   │   ├── [domain].module.ts
│   │   │   ├── [domain].service.ts
│   │   │   ├── [domain].controller.ts
│   │   │   ├── dto/         # Data Transfer Objects
│   │   │   ├── entities/   # Entidades de dominio
│   │   │   └── interfaces/ # Interfaces
│   │   └── ...
│   ├── config/              # Configuraciones
│   │   └── [config].ts
│   └── prisma/              # Prisma client
│       └── prisma.service.ts
├── prisma/
│   └── schema.prisma
├── package.json
└── tsconfig.json
```

## Mejores Prácticas

1. **Single Responsibility**: Cada paquete/servicio tiene una responsabilidad clara
2. **Dependency Inversion**: Depender de abstracciones (interfaces), no implementaciones
3. **Open/Closed**: Abierto para extensión, cerrado para modificación
4. **Interface Segregation**: Interfaces pequeñas y específicas
5. **DRY**: No repetir código, usar paquetes compartidos
6. **Separation of Concerns**: Separar lógica de negocio, infraestructura y presentación
7. **Domain-Driven Design**: Organizar por dominio de negocio cuando sea apropiado
